# PW6 实验报告

PB19000200 曾舒立 PB19000205 赵辰阳 PB19000173 李子涵

## 问题回答

#### **思考题**

**1-1** 请给出while语句对应的LLVM IR的代码布局特点，重点解释其中涉及的几个`br`指令的含义（包含各个参数的含义）

答：while语句对应的LLVM IR的代码布局特点通常需要三段代码，第一段表示条件判断，第二段表示while的主体语句，第三段是退出while循环后的代码，在第一段末尾会根据判断条件进行选择，若为真则进入第二段代码，若为假则进入第三段代码，在第二段语句的最后会无条件的返回第一段进行下一轮的判断。br指令分为条件跳转和无条件跳转，如下。

```cpp
br i1 <cond>, label <iftrue>, label <iffalse>		;条件跳转
br label <dest>          ;无条件跳转
```

- `i1 <cond>`这是一个布尔值，之所以是`i1`是因为`true`在内存中是1，`false`是0。在执行`br`指令的时候，会对整个值进行计算，如果是`true`就跳到`iftrue`基本块，否则就跳到`iffalse`。
- `label <iftrue>`, `label <iffalse>`这是两个`label`类型，分别对应两个基本块。

**1-2** 请简述函数调用语句对应的LLVM IR的代码特点

答：经过多段代码的观察学习，可以发现函数调用语句对应的LLVM IR代码都是以值传递，并且直接用返回值赋值的语句，比如%8 = call i32 @add(i32 %6, i32 %7)的，其中%8为add()的返回的int32类型值，%6为add()第一个参数的值，%7为add()第二个参数的值。与c语言函数调用没有多大区别，最大的区别是要显示的标明函数的返回类型(如果有)，也可以直接调用函数，无返回值`call @func( i32 %arg)`。

**2-1** 请给出`SysYFIR.md`中提到的两种getelementptr用法的区别, 并解释原因:

  - `%2 = getelementptr [10 x i32], [10 x i32]* %1, i32 0, i32 %0` 
  - `%2 = getelementptr i32, i32* %1, i32 %0`

答：GetElementPtr指令其实是一条指针计算语句，本身并不进行任何数据的访问或修改，进行是计算指针，修改计算后指针的类型。 GetElementPtr第一个参数为计算基础类型，第二第三个参数表示索引开始的指针类型及指针，即要进行计算的原始指针。第四个参数及以后的参数，都称为`indices`，表示要进行计算的参数，如结构体的第几个元素，数组的第几个元素，里面表示的数组索引的偏移类型及偏移值。如`%2 = getelementptr [10 x i32], [10 x i32]* %1, i32 0, i32 %0` 所示，其中最后两个参数分别为`i32 0`和`i32 %0`，`i32 0`是数组计算符，并不会改变返回的类型，因为，我们任何一个指针都可以作为一个数组来使用，进行对应的指针计算，所以这个0并不会省略。即仍在当前%1所指向位置进行查找，而`i32 %0`是数组的计算地址，表示的是数组第%0个元素的地址，这时，会根据指针的类型，选取其中的元素长度，进行计算，最后返回的则是%1[%0]的指针。 而`%2 = getelementptr i32, i32* %1, i32 %0`并不是数组类型，所以并不需要增加上个示例中最后一个参数，直接进行整体偏移的计算即可。

## 实验设计

## 实验难点及解决方案

## 实验总结

## 实验反馈

## 组间交流

- 11.24 初步完成任务进度规划，第一周完成第一关与第二关，并初步开始第三关的内容，第二周解决第三关；
- 11.26 由于第一关的难度不大，提前单人完成第一关，讨论并分享了第一关的理解与第二关的要求，并分配任务完成第二关中代码的书写；
- 11.27 讨论第三关的具体实现与代码分工

